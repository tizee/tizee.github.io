{"componentChunkName":"component---src-templates-post-jsx","path":"/post/8bf9f70431982378fb17a3278dbfbb1d","result":{"data":{"post":{"id":"26e60f9f-03a9-5b33-92cf-d990708a1ff0","excerpt":"About this post This is a summary post about algorithm exercises. The solutions may written in C++ or javaScript.  Common approach for most…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Techniques learnt from exercises\",\n  \"date\": \"2020-03-08\",\n  \"category\": \"algorithm\",\n  \"tags\": [\"summary\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"About this post\"), mdx(\"p\", null, \"This is a summary post about algorithm exercises. The solutions may written in C++ or javaScript. \"), mdx(\"h2\", null, \"Common approach for most problems\"), mdx(\"p\", null, \"We couold first consider simpler situation or some special cases that easy to be solved.\\nLike 3blue1brown said in his video \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://youtu.be/OkmNXy7er84\"\n  }), \"The hardest problem on the hardest test\"), \", you could first consider the 2D version problem and then use similiar idea in the higher 3D problem. Feynman also said smiliar idea.\"), mdx(\"p\", null, \"Hmm, it sounds like divide and conquer or dynamic-programming. The truth is both of them divide the original problem into smaller subproblems and we need to merge solutions of subproblems to get the answer we want.\"), mdx(\"p\", null, \"For example, to solve the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/create-maximum-number/\"\n  }), \"321. Create Maximum Number\"), \", you have to consider simple situations first.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var maxNumber = function(nums1, nums2, k) {\\n    /*\\n    Intuition:\\n    First consider simpler situation.\\n    1. If we only use one of arrays, what we would get.\\n    We could choose min(nums1.length,k) at most.\\n    We could drop nums1.length - min(nums1.length,k) at most.\\n\\n    2. If we only use two of arrays, what we would get.\\n    We could choose i numbers in nums1 and choose j numbers in nums2.\\n    Hence, i = min(nums1.length-k,0) and i <= min(nums1.length,k)\\n    j = k-i\\n\\n    we could simplifiy the question to above simple subproblem and merge the result to get the answer.\\n    \\n    */\\n    const m = nums1.length;\\n    const n = nums2.length;\\n    let ans = new Array(k).fill(0);\\n    let i = 0, j = 0,count = 0;\\n    const merge = (a,b)=>{\\n        let ans = [];\\n        while(a.length + b.length > 0){\\n            if(a>b){\\n               ans.push(a.shift());\\n            }else{\\n               ans.push(b.shift());\\n            }\\n        }\\n        return ans;\\n    }\\n    const getMaxArray = (arr,k)=>{\\n       const n = arr.length;\\n       let could_drop = n - k;\\n       let ans = []; \\n       for(let num of arr){\\n        while(could_drop>0&&ans.length>0&&ans[ans.length-1]<num){\\n            // smaller then reset\\n            ans.pop();\\n            could_drop--;\\n        }\\n         ans.push(num);\\n       }\\n       while(ans.length>k){\\n           ans.pop();\\n       }\\n       return ans;\\n    }\\n    for(let i = Math.max(k-n,0);i<=Math.min(k,m);i++){\\n        let candidate = merge(getMaxArray(nums1,i),getMaxArray(nums2,k-i));   \\n        if(candidate>ans){\\n           ans = candidate; \\n        }\\n    }\\n    return ans;\\n};\\n\")), mdx(\"p\", null, \"The question \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/minimum-height-trees/\"\n  }), \"310. Minimum Height Trees\"), \" could also be solved using this strategy.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var findMinHeightTrees = function(n, edges) {\\n   /*\\n  Brute force:\\n   Choose each node as root and use BFS to traversal the tree for the minimum height\\n   \\n  Intuition:\\n   Consider a simpler graph - path graph, the root of MHT is the middlest node of the tree.\\n   We could use two pointers to find such nodes.\\n   \\n   Now consider a tree. We could use multiple pointers that start from the leaves at the same speed and remove these leaves until there are 1 or 2 nodes left. Simliar to graph topologicalsort but we start from the leaves that out degree is 0.\\n   \\n   For a tree that has n nodes,there are always n-1 edges.\\n   */ \\n    if(n==1){\\n        return [0];\\n    }\\n    let neighbors = new Array(n);\\n    for(let i = 0;i<n;i++){\\n        neighbors[i] = new Set();\\n    }\\n    for(let edge of edges){\\n        neighbors[edge[0]].add(edge[1]);\\n        neighbors[edge[1]].add(edge[0]);\\n    }\\n    let leaves = [];\\n    for(let i =0;i<n;i++){\\n        if(neighbors[i].size==1){\\n            leaves.push(i);           \\n         }\\n    }\\n    while(n>2){\\n       n -= leaves.length; \\n       let next_level = [];\\n       for(let idx of leaves){\\n          let neighbor = neighbors[idx].values().next().value;\\n          neighbors[neighbor].delete(idx); \\n          if(neighbors[neighbor].size==1){\\n             next_level.push(neighbor); \\n          }\\n       }\\n        leaves = next_level;\\n    }\\n    return leaves;\\n};\\n\")), mdx(\"h3\", null, \"Define lines for graph\"), mdx(\"p\", null, \"Sometimes you could define line to simplify the question.\\nGo and check \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/self-crossing/\"\n  }), \"335. Self Crossing\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javaScript\"\n  }), \"var isSelfCrossing = function(x) {\\n    /*\\n    Intuition:\\n    Consider only line crosses itself\\n    \\n    Define lines:\\n    \\n    case 1\\n       b\\n    x------x\\n    |      | \\n    |    a |   f\\n c  |      |  --x\\n    |      x    |\\n    |           | e\\n    x-----------x\\n          d\\n          \\n  1. f >= b - d\\n  2. a >= c - e\\n          \\n    case 2\\n       b\\n    x------x\\n  c |      | \\n    |  d   | a  \\n    x---   | \\n           x   \\n  1. d >= b \\n  2. a >= c \\n    */\\n    let b=0,c=0,d=0,e=0,f=0;\\n    for(let a of x){\\n        if (d >= b && b > 0 && (a >= c || ((c - e) <= a && c >= e && (d - f) <= b)))\\n          {\\n            return true;\\n            }\\n        f = e; e = d; d = c; c = b; b = a;\\n    }\\n   return false; \\n};\\n\\n\")), mdx(\"h3\", null, \"With the help of mathematics\"), mdx(\"p\", null, \"It may be complicated as someone said but at least the first time I saw \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/integer-break/\"\n  }), \"343. Integer Break\"), \" I calculated its derivative to get the maximum. And then we could use it to get O(1) solution. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var integerBreak = function(n) {\\n    /*\\n    Intuition:\\n    a + b >= 2*sqrt(a*b)\\n    <=> x1 + x2 + ... + xn >= n*(x1*...*xn)^(1/n)\\n    when x1 = x2 = ... = xn, the equal is satisfised.\\n    \\n    For the question, we need to break the sum into suitable number of parts to get the answer but how.\\n    \\n    If n is divide by x, there are n/x x's which gives us the product x^(n/x).\\n    \\n    f(x) = x^(n/x) => f'(x) = (1-lnx)*n*x^(n/x - 2)\\n    0 < x < e: f'(x)>0\\n    x = e: f'(x) = 0\\n    x > e: f'(x)< 0\\n    \\n    The closest integer to e is 3. \\n    */\\n    if(n<2){\\n        return -1;\\n    }\\n    if(n==2)return 1;\\n    if(n==3)return 2;\\n    let n3 = Math.floor(n/3);\\n    let remainder = n%3;\\n    if(remainder==1){\\n       remainder = 4; \\n        n3--;\\n    }else if(remainder==0){\\n       remainder = 1; \\n    }\\n    return (3**n3) * remainder;\\n};\\n\")), mdx(\"h3\", null, \"Imitate recursive approach with stack\"), mdx(\"p\", null, \"In most of time I choose stack instead of recursive approach is due to the time complexity requirement.\\nOtherwise, you would get TLE on OJ.\"), mdx(\"p\", null, \"Many binary tree serializatin string verifying problems could be solved use stack e.g \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/\"\n  }), \"331. Verify Preorder Serialization of a Binary Tree\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var isValidSerialization = function(preorder) {\\n    /*\\n    Intuition:\\n    Use the stack to imitate recursive approach (dfs).\\n    \\n    1. If meet non-null node, we continue recursive calling and push it to stack.\\n    2. If meet null node, we return to above recursive calling and check the stack top.\\n    If stack top is also a null node, pop two nodes that one for left and one for parent each turn until top isn't a null node. If the stack is empty in poping process, then it's invalid.\\n    If not, push it to stack and continue.\\n    \\n    If the serialization string is correct, then there are only one null node in the stack.\\n    Otherwise it's not correct.\\n    */\\n    let stack = [];\\n    let nodes = preorder.split(',');\\n    for(let node of nodes){\\n       if(node=='#'&&stack.length>0&&stack[stack.length-1]=='#'){\\n            while(stack.length>0&&stack[stack.length-1]=='#') {\\n               stack.pop(); \\n               if(stack.length==0){\\n                   return false;\\n               }\\n                stack.pop();\\n            }   \\n       } \\n      stack.push(node);  \\n    }\\n    return stack.length == 1&&stack[0]=='#';\\n};\\n\")), mdx(\"h3\", null, \"Relationship between tree and graph\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/\"\n  }), \"331. Verify Preorder Serialization of a Binary Tree\"), \".\\ncould also be solved with the degree in graph.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var isValidSerialization = function(preorder) {\\n    /*\\n    Intuition:\\n    1. In pre-order traversal, first visit the node, then traverse on left subtree, finally traverse on right subtree.\\n    2. As there are always symbols for null nodes, the non-nodes in string must have left child and right child.\\n    3. One non-null node produces 2 edges and consumes 1 edge which increase edge by 1 in total.\\n       And one null node produces 0 edges and consumes 1 edge which decrease edge by 1 in total.\\n       Each time we meet a node, we derease the edges by 1 as it consumes one edge.\\n       If it's not null, then we increase 2 edges.\\n       If it's null, we repeat the process.\\n       \\n       If the serialization string is correct, the final edge number is 0 as there no more redundant edges. \\n       Otherwise it's not correct.\\n    */\\n    let nodes = preorder.split(',');\\n    let edges = 1;\\n    for(let node of nodes){\\n       edges -= 1;\\n       if(edges<0){\\n           return false;\\n       }\\n       if(node!='#'){\\n           edges += 2;\\n       }\\n    }\\n    return edges == 0;\\n};\\n\\n\")), mdx(\"h3\", null, \"use bit to store simple state\"), mdx(\"p\", null, \"In most languages, integer are defined using two's complement for representation and float point number uses IEEE-754 standard. \"), mdx(\"p\", null, \"The most common use for bit is to represent states so we could use it to reduce both time and space complexity. For example, the question \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/maximum-product-of-word-lengths/\"\n  }), \"Maximum Product of Word Lengths\"), \". \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var maxProduct = function(words) {\\n    /*\\n    Intuition:\\n    To get the maximum value of two words with no common letters, we need to filter such no common letter words for each word.\\n    To improve efficiency, we could use bit to store state of each letter for a word instaed of HashMap.\\n    */\\n    words = words.map(word=>{\\n        let memoBit = 0;\\n        for(let i = 0;i<word.length;i++){\\n            memoBit |= (1<<(word.charCodeAt(i)-97));\\n        }\\n        return [memoBit,word.length];\\n    })\\n    let ans = 0;\\n    for(let i = 0;i<words.length-1;i++){\\n        for(let j = i+1;j<words.length;j++){\\n            if((words[i][0]&words[j][0])==0){\\n                ans = Math.max(words[i][1]*words[j][1],ans);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n\")), mdx(\"h3\", null, \"Iterator Cache\"), mdx(\"p\", null, \"We could use two variable to cache iterator for peeking.\\nHere is the related problem \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/peeking-iterator/\"\n  }), \"Cached peeking iterator\"), \".\\nThat Google's java library grava also use similiar approach. \"), mdx(\"h3\", null, \"Skip operations\"), mdx(\"p\", null, \"In some problems we are asked to do some operations on the input in order to calculate sort of optimal value.\\nIronically, we could skip such operations.\\nPlease check the problem \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/different-ways-to-add-parentheses/\"\n  }), \"241. Different Ways to Add Parentheses\"), \" which I did add parentheses to input at first. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var mem = new Map();\\nvar ops = ['*','-','+'];\\n\\nvar diffWaysToCompute = function(input) {\\n    /*\\n    We could use divide and conquer here.\\n    But at first we must have this idea that adding parentheses equals to deciding which part compute first.\\n    Moreover, the question require the computed results instead of expressions so we do not need to add parentheses actually and we just split the input into two parts: left and right.\\n    Now it's obvious that we could use divide and conquer here to repeat the above process until reaching the\\n    simplest subproblem.\\n    */\\n    if(mem.has(input)){\\n        return mem.get(input);\\n    }\\n    let ans = [];    \\n    for(let i = 0;i<input.length;i++){\\n        if(ops.includes(input[i])){\\n            let left =  input.slice(0,i); \\n            let right = input.substring(i+1);\\n            let left_ans = diffWaysToCompute(left);\\n            let right_ans= diffWaysToCompute(right);\\n            for(let a of left_ans){\\n                for(let b of right_ans){\\n                    switch(input[i]){\\n                        case '+':\\n                            ans.push(a+b);\\n                            break;\\n                        case '-':\\n                            ans.push(a-b);\\n                            break;\\n                        case '*':\\n                            ans.push(a*b);\\n                            break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    if(ans.length==0){\\n        // the simplest subproblem\\n        ans.push(Number.parseInt(input));\\n    }\\n    mem.set(input,ans);\\n    return ans;\\n};\\n\")), mdx(\"h3\", null, \"Bit count\"), mdx(\"p\", null, \"Here comes the Brian Kernighan's algorithm. It could be used to count set bit in a number. The key operation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x&=(x-1)\"), \" that would remove the last set bit.\"), mdx(\"p\", null, \"Here is a problem \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/bitwise-and-of-numbers-range/\"\n  }), \"201. Bitwise AND of Numbers Range\"), \" could solved using this trick.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var rangeBitwiseAnd = function(m, n) {\\n    while(n>m){\\n        n &= (n-1);\\n    }\\n    return n;\\n};\\n// or\\nvar rangeBitwiseAnd = function(m, n) {\\n    let right_common = 0;\\n    while(m!=n){\\n        m>>=1;\\n        n>>=1;\\n        right_common++;\\n    }\\n    return m<<right_common;\\n};\\n\")), mdx(\"p\", null, \"And it could also be used to solve problem \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/single-number-iii/\"\n  }), \"260. Single Number III\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"var singleNumber = function(nums) {\\n    /*\\n    Intuition:\\n        a XOR a = 0\\n        a XOR 0 = a\\n        \\n        Assume the two distinct element in array are x and y.\\n        If we XOR all elements, then the result would be x XOR y.\\n        As x and y are distinct, there must be at least one set bit in the result.\\n        Here we could use the rightmost set bit in the result to divide the array into two parts.\\n        One with this set bit and another with this bit unset. In this way x and y would fall into different group.\\n        \\n        Then we could XOR all numbers in each group to get x and y directly.\\n        \\n        \\n    */\\n    let x_y = 0;\\n    for(let i = 0;i<nums.length;i++){\\n       x_y ^= nums[i]; \\n    }\\n    const getLowBit = x => x&(-x);\\n    const checkBit = (bit,x)=>{\\n       if((x&bit)==bit){\\n           return true;\\n       } else{\\n           return false;\\n       }\\n    }\\n    let bit = getLowBit(x_y);\\n    let x = 0, y = 0;\\n    for(let i = 0;i<nums.length;i++){\\n        if(checkBit(bit,nums[i])){\\n            x ^= nums[i];\\n        }else{\\n            y ^= nums[i];\\n        }\\n    }\\n    return [x,y];\\n};\\n\")), mdx(\"h3\", null, \"Binary Indexed Tree\"), mdx(\"p\", null, \"Binary indexed tree is a great data structure for range sum problem.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/problems/range-sum-query-mutable/\"\n  }), \"Range Sum Query - Mutable\"), \" is a good practise for implementing this data structure.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp\"\n  }), \"class NumArray {\\nprivate:\\n    class BinaryIndexedTree{\\n        private:\\n            /*\\n            Assume vals[y] is parent node of child node vals[x], we have\\n             (1) y = x - (x & (-x))\\n             (2) vals[x] = sum of arr[y...x)\\n            */\\n            vector<int> vals; \\n            int _size;\\n            static inline int getLowBit(int i){\\n                return i & (-i);\\n            }\\n        public:\\n            BinaryIndexedTree(int size): _size(size), vals(size+1,0){}\\n        \\n            void update(int i,int val){\\n                i = i + 1;\\n                while(i<=_size){\\n                   vals[i] += val; \\n                   i += getLowBit(i);\\n                }\\n            }\\n        \\n            // sum of [0...i]\\n            int getSum(int i){\\n                int sum = 0;\\n                i = i + 1;\\n                while(i>0){\\n                   sum += vals[i];  \\n                   i -= getLowBit(i);\\n                }\\n                return sum;\\n            }\\n    };\\n    BinaryIndexedTree tree;\\n    vector<int> vals;\\npublic:\\n    NumArray(vector<int>& nums):tree(nums.size()),vals(nums){\\n        for(int i = 0;i<nums.size();i++){\\n           tree.update(i,nums[i]); \\n        }\\n    }\\n    \\n    void update(int i, int val) {\\n       tree.update(i,val-vals[i]); \\n       vals[i] = val;\\n    }\\n    \\n    int sumRange(int i, int j) {\\n       return tree.getSum(j)-tree.getSum(i-1);\\n    }\\n};\\n\")), mdx(\"h3\", null, \"End of post\"), mdx(\"p\", null, \"Solving algorithm problems is time consuming and it's not as fun as developing but it worth time practising some often used algorithms and data structures.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"date":"2020-03-08","title":"Techniques learnt from exercises","category":"algorithm","tags":["summary"],"slug":"8bf9f70431982378fb17a3278dbfbb1d"},"timeToRead":2,"tableOfContents":{"items":[{"url":"#about-this-post","title":"About this post"},{"url":"#common-approach-for-most-problems","title":"Common approach for most problems","items":[{"url":"#define-lines-for-graph","title":"Define lines for graph"},{"url":"#with-the-help-of-mathematics","title":"With the help of mathematics"},{"url":"#imitate-recursive-approach-with-stack","title":"Imitate recursive approach with stack"},{"url":"#relationship-between-tree-and-graph","title":"Relationship between tree and graph"},{"url":"#use-bit-to-store-simple-state","title":"use bit to store simple state"},{"url":"#iterator-cache","title":"Iterator Cache"},{"url":"#skip-operations","title":"Skip operations"},{"url":"#bit-count","title":"Bit count"},{"url":"#binary-indexed-tree","title":"Binary Indexed Tree"},{"url":"#end-of-post","title":"End of post"}]}]}}},"pageContext":{"id":"26e60f9f-03a9-5b33-92cf-d990708a1ff0","previous":{"post":{"id":"5e06e1ab-e941-58bf-a247-d1137ef38cae","parent":{"id":"3e3fd6e9-090c-5b50-a192-5089f2167fc4"},"excerpt":"Note enable SMB in Windows functions. make sure both machine with MacOS and machine with Windows connect to the same local network. (Do not…","slug":"c313244699ae2b9bb25017518095b96b","title":"Access files on Windows10 on MacOS","tags":["mac"],"category":"configs","date":"2020-03-07"}},"next":{"post":{"id":"ed21203b-2ab3-5915-b3ec-7a1133c08132","parent":{"id":"c4d57da4-1fc8-5b15-b028-438eb9f9229b"},"excerpt":"由于政府严格有力的举措，以及广大人民的响应与配合，新型肺炎在国内实现了 0增长 。而与之对比的是，国外的疫情不断爆发，其中 美国确诊病例超10万 ，超过中国跃居第一，川统领的America First…","slug":"a19e9a933a5cb142478021db6f65c96a","title":"就业与时下的疫情","tags":["随笔","Chinese"],"category":"thoughts","date":"2020-03-28"}}}}}